@inject IJSRuntime JSRuntime

<style>
	.swig {
		background-color: rgb(20,20,20);
		width: 100vw; 
		height: 80vh;
	}

	.galaxy-box {
		stroke: darkgray;
		stroke-width: 2px;
		fill: black;
	}

	.grid-line {
		stroke: darkgray;
	}

	.grid-level-1 {
		stroke-width: 0.75px;
	}

	.grid-level-2 {
		stroke-width: 0.5px;
	}

	.grid-level-3 {
		stroke-width: 0.25px;
	}

	.planet {
		fill: lightblue;
		r: 1.5px;
	}
</style>

@if (Galaxy != null)
{
	<svg viewBox="@Box"
		  class="swig"
		  id="svg"
		  @ref="SVG"
		  @onclick="TargetObject"
		  @onwheel="Zoom"
		  @onmousemove="Hover">

		<rect x="@(-gridSide)" y="@(-gridSide)" width="@Galaxy.Size" height="@Galaxy.Size" class="galaxy-box" />
		
		@foreach (var (coord, level) in GetGridLines())
		{
			<line x1="@(-gridSide)" x2="@gridSide" y1="@coord" y2="@coord" class="@($"grid-line grid-level-{level}")" />
			<line y1="@(-gridSide)" y2="@gridSide" x1="@coord" x2="@coord" class="@($"grid-line grid-level-{level}")" />
		}

		@foreach (var p in Galaxy.Planets)
		{
			<circle cx="@p.Position.X" cy="@p.Position.Y" class="planet" />
		}

		@ChildContent
	</svg>
}

@code
{
	private IEnumerable<(int,int)> GetGridLines()
	{
		yield return (-gridSide * 3 / 4, 3);
		yield return (-gridSide / 4, 3);
		yield return (-gridSide / 2, 2);
		yield return (0, 1);
		yield return (gridSide / 2, 2);
		yield return (gridSide / 4, 3);
		yield return (gridSide * 3 / 4, 3);
	}

	int gridMid => 0;
	int gridSide => Galaxy.Size / 2;

	int screenHeight = 800; // TODO: Set div to fullscreen and get size here
	int screenWidth = 1500; // TODO: Set div to fullscreen and get size here

	ElementReference SVG;

	private ViewBox Box { get; set; }
	private Position zoomPosition;

	[Parameter]
	public double ScaleRate { get; set; } = 1;

	[Parameter]
	public Galaxy Galaxy { get; set; }

	[Parameter]
	public RenderFragment ChildContent { get; set; }

	[Parameter]
	public EventCallback<Planet> OnPlanetSelected { get; set; }

	[Parameter]
	public EventCallback<double> ScaleRateChanged { get; set; }

	protected override void OnInitialized()
	{
		ResetViewBox();
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		await SetScreenSize();
	}

	private async Task TargetObject(MouseEventArgs e)
	{
		Position clickCoords = await JSRuntime.InvokeAsync<Position>("retrieveElementPosition", SVG, e);
		var target = Galaxy.ClosestPlanet(clickCoords);
		await OnPlanetSelected.InvokeAsync(target);
	}

	private async Task Zoom(WheelEventArgs e)
	{
		zoomPosition = await JSRuntime.InvokeAsync<Position>("retrievePosFromCorner", SVG, e);
		int wheel = e.DeltaY < 0 ? 1 : -1;
		UpdateViewBox(zoomPosition.X, zoomPosition.Y, wheel);
	}

	private async Task Hover(MouseEventArgs e)
	{
		await JSRuntime.InvokeVoidAsync("hover", SVG, e);
	}

	private async Task SetScreenSize()
	{
		var screen = await JSRuntime.InvokeAsync<ViewBox>("retrieveScreenSize");
		screenHeight = screen.Height;
		screenWidth = screen.Width;
	}

	private void UpdateViewBox(int zoomX, int zoomY, int wheel)
	{
		var zoomIntensity = 0.2;
		var zoom = Math.Exp(wheel * zoomIntensity);
		// Calculate new corner node so the mouse position is the same before and after the zoom
		int x = Box.X - (int)(zoomX / (ScaleRate * zoom) - zoomX / ScaleRate);
		int y = Box.Y - (int)(zoomY / (ScaleRate * zoom) - zoomY / ScaleRate);
		ScaleRate *= zoom;

		int height = (int)(screenHeight / ScaleRate);
		int width = (int)(screenWidth / ScaleRate);

		Box = new ViewBox()
		{
			X = x,
			Y = y,
			Height = height,
			Width = width
		};

		ScaleRateChanged.InvokeAsync(ScaleRate);
	}

	public void ResetViewBox()
	{
		Box = new ViewBox()
		{
			X = -(1500/ 2),
			Y = -(Galaxy.Size / 2),
			Height = screenHeight,
			Width = screenWidth
		};
	}

	public struct ViewBox
	{
		public int X { get; set; }
		public int Y { get; set; }
		public int Width { get; set; }
		public int Height { get; set; }
		public int MidX => X + Width / 2;
		public int MidY => Y + Height / 2;

		public override string ToString() => $"{X} {Y} {Width} {Height}";
	}
}
