@inject IJSRuntime JSRuntime

<style>
	.swig {
		background-color: rgb(30,30,30);
	}

	.galaxy-box {
		stroke: darkgray;
		stroke-width: 2px;
		fill: black;
	}

	.grid-line {
		stroke: darkgray;
		stroke-width: 0.5px;
	}

	.planet {
		fill: lightblue;
		r: 1.5px;
	}
</style>

@if (Galaxy != null)
{
	<svg viewBox="@Box"
		  width="1500" height="800"
		  class="swig"
		  @ref="SVG"
		  @onclick="TargetObject"
		  @onwheel="Zoom">

		<rect x="@(-gridSide)" y="@(-gridSide)" width="@Galaxy.Size" height="@Galaxy.Size" class="galaxy-box" />

		<line x1="@(-gridSide)" x2="@gridSide" y1="0" y2="0" class="grid-line" />
		<line y1="@(-gridSide)" y2="@gridSide" x1="0" x2="0" class="grid-line" />

		@foreach (var p in Galaxy.Planets)
		{
			<circle cx="@p.Position.X" cy="@p.Position.Y" class="planet" />
		}

		@ChildContent
	</svg>
}

@code
{
	int gridMid => 0;
	int gridSide => Galaxy.Size / 2;

	ElementReference SVG;

	private ViewBox Box { get; set; }
	private Position zoomPosition;
	private double ScaleRate { get; set; }

	private Galaxy _galaxy;

	[Parameter]
	public Galaxy Galaxy
	{
		get => _galaxy;
		set
		{
			_galaxy = value;
			ResetViewBox();
		}
	}

	[Parameter]
	public RenderFragment ChildContent { get; set; }

	[Parameter]
	public EventCallback<Planet> OnPlanetSelected { get; set; }

	protected override void OnInitialized()
	{
		ScaleRate = 1;
		ResetViewBox();
	}

	private async Task TargetObject(MouseEventArgs e)
	{
		Position clickCoords = await JSRuntime.InvokeAsync<Position>("retrieveElementPosition", SVG, e);
		var target = Galaxy.ClosestPlanet(clickCoords);
		await OnPlanetSelected.InvokeAsync(target);
	}

	private async Task Zoom(WheelEventArgs e)
	{
		zoomPosition = await JSRuntime.InvokeAsync<Position>("retrievePosFromCorner", SVG, e);
		int wheel = e.DeltaY < 0 ? 1 : -1;
		UpdateViewBox(zoomPosition.X, zoomPosition.Y, wheel);
	}

	private void UpdateViewBox(int zoomX, int zoomY, int wheel)
	{
		var zoomIntensity = 0.2;
		var zoom = Math.Exp(wheel * zoomIntensity);
		// Calculate new corner node so the mouse position is the same before and after the zoom
		int x = Box.X - (int)(zoomX / (ScaleRate * zoom) - zoomX / ScaleRate);
		int y = Box.Y - (int)(zoomY / (ScaleRate * zoom) - zoomY / ScaleRate);
		ScaleRate *= zoom;
		int height = (int)(Galaxy.Size / ScaleRate);

		Box = new ViewBox()
		{
			X = x,
			Y = y,
			Height = height,
			Width = height
		};

	}

	private void ResetViewBox()
	{
		Box = new ViewBox()
		{
			X = -(Galaxy.Size / 2),
			Y = -(Galaxy.Size / 2),
			Height = Galaxy.Size,
			Width = Galaxy.Size
		};
	}

	public struct ViewBox
	{
		public int X { get; set; }
		public int Y { get; set; }
		public int Width { get; set; }
		public int Height { get; set; }
		public int MidX => X + Width / 2;
		public int MidY => Y + Height / 2;

		public override string ToString() => $"{X} {Y} {Width} {Height}";
	}
}
